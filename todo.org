* add method
** add method type
** compile id to call
** add --/++ methods
* add tests
** add scope.Load(path)
** add load method
** call on args in main
* add Loop op
** add Break/Next error
*** trap in Loop.Evaluate
** add while macro to lib/abc

macro: while: (cond body) {
  '(loop: (@cond else: break @body))
}

* add pairs
** a b,
** add pair form
* add Trait/TraitBase
** use as parent for Type/TypeBase
** add TAny
* add function/method
** trait/index/val args
** trait/index rets
** add function/method types
** add dispatch op
** always run in separate scope
*** peel of scope body like thread

method: foo (a b) {...}
method: foo (a Any, b Any) {...}

* add first class scopes
** add scope method
*** return clone
** add new(Scope) method
*** return empty scope
** add scope: macro
*** add ScopeOp.pop bool
** add dot access in Id
*** pop scope if first char == '.' and second char != '.'

let: foo new(scope) 
foo.let: bar 42 
foo scope: {bar}

* add Splat op
** add Type.Splat
*** implement for Int
**** 3... -> 0 1 2
*** implement for Slice
*** implement for String
**** add Char type
** add ... macro
