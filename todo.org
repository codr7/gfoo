* add Record type
** add basic tests
** make Tree immutable
*** trace paths on update & create new nodes
*** return updated tree

let: r record: ('foo 1 'bar 2 'baz 3)
r r.foo r.bar r.baz r.qux.foo.bar
r set('qux 4)
r merge(record: ('foo 4 'qux 5))
* add union types
** add Union with list of types
** parse X|Y as union
*** handle in ParseId
** add Type.ReverseIsa
*** call Isa for all types
** replace uses of Isa with ReverseIsa
* add scope method
** return current scope
* add Ratio type
** use big.Rat
** add Int / with Ratio result
* add negation using !
** NotForm
** compile value 
** emit Not op
*** call .Bool
* add and/or macros
* add String interpolation
** read form following @ & print last value
** add Writer type
** add Type.Print(Val, Writer) error
** add Type.String() string
** add print method
** use bytes.Buffer
** compile form, call: Print with buffer, call: Print with buffer/string, call: String with buffer 

let: foo 42 "@(foo)bar"

* add Loop op
** add Break/Next error
*** trap in Loop.Evaluate
** add while macro to lib/abc

macro: while: (cond body) {
  '(loop: (@cond else: break @body))
}

* add Splat op
** add Type.Splat
*** implement for Int
**** 3... -> 0 1 2
*** implement for Slice
*** implement for String
**** add Char type
** add ... macro

type: Quantity Record

method: new-quantity(; Quantity) {
  record->quantity(record: ('start time.MIN 'end time.MAX 'total 0 'available 0))
}

type: Calendar Slice

method: new-calendar(; Calendar) {
  slice->calendar([new-quantity])
}

type: Resource Record

method: new-resource (; Resource) {
  record->resource(record: ('calendar new-calendar))
}
